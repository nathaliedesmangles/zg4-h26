+++
pre = 'Semaine 8 : '
title = 'Redirections, Pipe & Examen #2'
weight = 80
+++


## Objectif de la semaine

Comprendre comment manipuler les flux de donn√©es pour combiner des commandes simples et r√©aliser des t√¢ches complexes.

**Fichier pour les exercices (en classe)**
Utiliser le fichier **exo-semaine8.docx** pour y mettre vos r√©ponses et captures d'√©cran.  
{{% button href="/docs/Exercices/exo-semaine8.docx" icon="download" %}}T√©l√©charger le fichier docx{{% /button %}}

---

# Th√©orie

Imaginez qu'une commande Linux est une **machine industrielle**. Elle a besoin de mati√®res premi√®res pour fonctionner et elle produit quelque chose en sortie.

Il existe trois "tuyaux" connect√©s par d√©faut √† chaque commande :

| Canal | Nom technique | ID | Description | Direction par d√©faut |
| --- | --- | --- | --- | --- |
| **Entr√©e** | `stdin` | 0 | Les donn√©es brutes | Votre **Clavier** |
| **Sortie** | `stdout` | 1 | Le bon r√©sultat | Votre **√âcran** |
| **Erreur** | `stderr` | 2 | Les messages de panne | Votre **√âcran** |

> **Analogie :** C'est comme une cr√©ature qui **mange** (stdin), **parle** (stdout) et parfois **crie** quand elle a mal (stderr).


## Les redirections

Par d√©faut, la "rivi√®re" de donn√©es coule vers l'√©cran. Nous pouvons utiliser des chevrons pour d√©tourner ce flux vers un **fichier**.

### 1. Le destructeur (`>`)

Le chevron simple redirige la sortie vers un fichier.

* **Attention :** Si le fichier existe, il est **√©cras√©** (vid√© et remplac√©).
* **Moyen mn√©motechnique :** Le fichier est remis √† z√©ro.

```bash
echo "Liste de courses" > courses.txt
# Le fichier courses.txt contient maintenant uniquement : Liste de courses
```

### 2. Le constructeur (`>>`)

Le double chevron ajoute les donn√©es √† la **fin** du fichier existant.

* **S√©curit√© :** Il ne d√©truit pas l'ancien contenu.

```bash
echo "- Pommes" >> courses.txt
echo "- Bananes" >> courses.txt
# Le fichier contient maintenant le titre ET les fruits.
```

### üü¢ Exercice #1 (En classe)

**Objectif :** Visualiser la diff√©rence entre √©craser et ajouter.

1. Demandez aux √©tudiants de taper : `echo "Bonjour" > test.txt`
2. Puis : `echo "Monde" > test.txt`
3. V√©rifiez le contenu (`cat test.txt`). Que s'est-il pass√© ? (R√©ponse : "Bonjour" a disparu).
4. Corrigez le tir : `echo "Bonjour" >> test.txt` (Pour avoir Monde et Bonjour).



## Le Tube (Pipe `|`) 

C'est le super-pouvoir de Linux. Le caract√®re `|` (Alt Gr + 6) connecte la sortie de la commande de gauche √† l'entr√©e de la commande de droite.

**La r√®gle d'or :** Pas de fichier interm√©diaire. Tout se passe en m√©moire vive (RAM).

> **Analogie de l'usine :**
> `Machine A (Fabrique le biscuit)` **|** `Machine B (Met le chocolat)` **|** `Machine C (Emballe)`

<!--
# R√©vision

Aujourd'hui, on n'apprend rien de nouveau. On va juste apprendre √† ne pas se tirer dans le pied le jour de l'examen.


## Module 1 : Gestion des Utilisateurs (Le pi√®ge du `-G`)

L'erreur fatale ici est la suppression accidentelle des groupes secondaires (comme `sudo`).

### üõë L'erreur classique

L'√©tudiant veut ajouter l'utilisateur `bob` au groupe `developers`.
Il tape : `usermod -G developers bob`

**Pourquoi c'est grave ?**
Cette commande **remplace** tous les groupes secondaires par `developers`. Si `bob` √©tait dans le groupe `sudo` ou `adm`, il vient de perdre ses droits d'administrateur.

### ‚úÖ La Correction

Il faut **A**jouter (Append).
La commande : `usermod -aG developers bob`

> **Moyen mn√©motechnique :** "Il faut **a**jouter, pas √©craser." (Think **A**ppend).

### ‚ö° Quiz Rapide (Main lev√©e)

1. Si je tape `useradd toto` sans options, est-ce que son dossier `/home/toto` est cr√©√© ?
* *R√©ponse : Non ! (Sur la plupart des distros brutes). Il faut l'option `-m`.*


2. Si je ne pr√©cise pas de shell, quel shell a-t-il par d√©faut ?
* *R√©ponse : Souvent `/bin/sh` (beurk) et non `/bin/bash`. Il faut `-s /bin/bash`.*



---

## Module 2 : Permissions (Le paradoxe du 'x')

Les √©tudiants confondent souvent le droit d'ex√©cution sur un *fichier* et sur un *dossier*.

### üõë L'erreur classique

"Monsieur, j'ai mis `chmod 444` (lecture seule) sur le dossier, mais je ne peux pas faire un `ls` dedans ni faire `cd` !"

**Pourquoi c'est grave ?**
Sur un dossier, **Lecture (r)** permet de lister les noms des fichiers, mais **Ex√©cution (x)** permet de "traverser" le dossier (entrer dedans). Sans le `x`, le `r` ne sert presque √† rien.

### üîç Le test de compr√©hension (Tableau)

Dessinez ceci au tableau et demandez ce qui se passe pour l'utilisateur `bob` (qui n'est pas propri√©taire) :

* **Fichier :** `rapport.txt` (rw- r-- ---)
* **Dossier :** `/dossier_secret` (rwx rw- ---)

**Question :** `bob` fait partie du groupe propri√©taire. Peut-il supprimer `rapport.txt` ?

* *R√©ponse (Pi√®ge) :* √áa d√©pend des droits du **dossier parent** ! Pour supprimer un fichier, on modifie le dossier, pas le fichier. Si Bob a `w` sur le dossier, il peut supprimer le fichier m√™me s'il est en lecture seule (`r--`) pour lui.

### ‚úÖ La R√®gle d'or du `chmod -R`

Ne jamais faire `chmod -R 777 /`. Jamais.
Si on veut donner acc√®s au groupe `web` sur tout un site :
`chown -R :web /var/www`
`chmod -R 770 /var/www` (Beaucoup plus propre que 777).

---

## Module 3 : Processus (Le tueur en s√©rie)

L'erreur ici est la brutalit√© inutile et la confusion entre pause et arr√™t.

### üõë L'erreur classique

"Mon programme ne r√©pond pas, je fais `Ctrl+Z`."

**Pourquoi c'est grave ?**
`Ctrl+Z` ne tue pas le processus, il le met en **pause** (SIGSTOP). Le processus consomme encore de la RAM, il est juste "gel√©". Si vous en faites 10, vous saturez la m√©moire sans le savoir.

* Il fallait faire `Ctrl+C` (SIGINT) pour tuer.

### üõë L'abus du `kill -9`

L'√©tudiant tape syst√©matiquement `kill -9 1234`.

**Pourquoi c'est grave ?**
C'est le "sniper" (SIGKILL). Le processus meurt instantan√©ment sans sauvegarder ses donn√©es, sans fermer ses connexions r√©seau, sans nettoyer ses fichiers temporaires.

* **Bonne pratique :** Toujours essayer `kill -15` (SIGTERM) ou juste `kill PID` d'abord (la demande polie). N'utiliser `-9` qu'apr√®s 10 secondes si √ßa r√©siste.

---

## Activit√© Finale : "Le Jeu du Sabotage" (15 min)

Pour finir la s√©ance sur une note ludique et active.

1. **Bin√¥mes :** Mettez les √©tudiants par deux.
2. **Sabotage (5 min) :** L'√©tudiant A doit cr√©er **une** erreur subtile sur la VM (ex: changer les droits de `/tmp` pour qu'on ne puisse plus √©crire, mettre un processus `sleep` cach√©, changer le shell de root en `/bin/false`).
3. **D√©bogage (5 min) :** Ils √©changent de place. L'√©tudiant B doit trouver pourquoi "√ßa marche pas" et r√©parer.
4. **Debrief :** On regarde ensemble les sabotages les plus vicieux.

### Liste de v√©rification ultime pour l'examen (√† distribuer)

* [ ] **Utilisateurs :** Ai-je v√©rifi√© le fichier `/etc/passwd` apr√®s avoir cr√©√© un user ?
* [ ] **Groupes :** Ai-je bien mis `-aG` et pas `-G` ?
* [ ] **Permissions :** Si je cr√©e un dossier partag√©, ai-je pens√© au *Sticky Bit* ou au *SGID* ?
* [ ] **Processus :** Ai-je v√©rifi√© avec `jobs` que je n'ai pas laiss√© plein de trucs en pause ?
* [ ] **Sudo :** Est-ce que mes commandes n√©cessitent `sudo` ? (Erreur b√™te : taper la commande, se faire rejeter, retaper).

-->
---

# Examen 2

### Titre de l'examen : "Mission SysAdmin - Sauvetage du Serveur Alpha"

**Contexte :** Vous √™tes le nouvel administrateur syst√®me de l'entreprise *DataCorp*. L'ancien administrateur est parti pr√©cipitamment. Il a laiss√© le serveur dans un √©tat instable, des comptes mal configur√©s et des processus douteux qui tournent.

**Objectif :** Remettre de l'ordre, s√©curiser les acc√®s et g√©rer les ressources.

---

### Partie 1 : Gestion des Utilisateurs et Groupes (30 min)

*L'objectif est de v√©rifier la compr√©hension de la structure des groupes et des param√®tres de compte, pas juste la cr√©ation.*

**Mise en situation :**
Le d√©partement "D√©veloppement" accueille deux nouveaux stagiaires, mais l'ancien admin a fait n'importe quoi avec le compte du chef d'√©quipe.

1. **R√©paration de compte :** L'utilisateur `chef_dev` existe d√©j√† (cr√©√© par le prof au pr√©alable), mais il ne peut pas se connecter.
* *Diagnostic attendu :* L'√©tudiant doit v√©rifier `/etc/passwd` et remarquer que le shell est `/bin/false` ou `/usr/sbin/nologin`.
* *Action :* Changer le shell pour `/bin/bash`.


2. **Architecture de groupe :** Cr√©ez deux groupes : `frontend` et `backend`.
3. **Cr√©ation intelligente :** Cr√©ez l'utilisateur `alice`.
* Elle doit appartenir au groupe principal `frontend`.
* Elle doit aussi avoir acc√®s au groupe `backend`.
* **Contrainte de s√©curit√© :** Son compte doit expirer automatiquement le 31 d√©cembre de l'ann√©e en cours (fin du stage).
* **Contrainte de confort :** Lors de sa premi√®re connexion, elle doit √™tre forc√©e de changer son mot de passe.



### Partie 2 : Permissions et Droits d'acc√®s (40 min)

*L'objectif est de tester les bits sp√©ciaux (SGID, Sticky) et la logique des droits, car c'est l√† que r√©side la vraie compr√©hension.*

**Mise en situation :**
L'√©quipe a besoin de collaborer sur des fichiers sensibles, mais la confidentialit√© est critique.

1. **Le Dossier Projet :** Cr√©ez un dossier `/opt/projet_secret`.
2. **Propri√©t√© :** Ce dossier doit appartenir √† l'utilisateur `chef_dev` et au groupe `backend`.
3. **Matrice de droits (Le c≈ìur du test) :** Configurez les permissions pour respecter **exactement** ces r√®gles :
* Le propri√©taire a tous les droits.
* Les membres du groupe `backend` peuvent lire, ex√©cuter et **cr√©er** des fichiers dedans.
* Les autres (others) ne doivent avoir **aucun acc√®s** (m√™me pas entrer dans le dossier).


4. **L'h√©ritage (SGID) :** Faites en sorte que tout fichier cr√©√© dans ce dossier par `alice` appartienne automatiquement au groupe `backend`, et non au groupe `frontend` (son groupe principal).
5. **La s√©curit√© de suppression (Sticky Bit) :** Cr√©ez un dossier `/opt/echanges`. Tout le monde doit pouvoir √©crire dedans, MAIS un utilisateur ne doit pas pouvoir supprimer les fichiers d'un autre utilisateur.

### Partie 3 : Gestion des Processus (20 min)

*L'objectif est de manipuler des processus en temps r√©el et de comprendre les priorit√©s.*

**Mise en situation :**
Le serveur est lent. Un script lanc√© par l'ancien admin consomme trop de ressources.

1. **Identification :** Trouvez le processus nomm√© `minage_crypto.sh` (lanc√© par le prof au d√©but) qui tourne en arri√®re-plan. Notez son PID dans un fichier `reponse_proc.txt`.
2. **Gestion de priorit√© (Nice) :** Ne tuez pas le processus tout de suite (il contient des donn√©es non sauvegard√©es). Changez sa priorit√© pour qu'il soit le moins prioritaire possible ("niceness" maximale) afin de lib√©rer le CPU pour les autres.
3. **Manipulation :** Mettez ce processus en pause (suspend), puis relancez-le en arri√®re-plan (bg).
4. **Nettoyage :** Finalement, le chef demande l'arr√™t complet. Envoyez le signal de terminaison propre (SIGTERM) au processus. S'il ne r√©pond pas apr√®s 10 secondes, forcez l'arr√™t (SIGKILL).

---

### Guide pour l'enseignant (Mise en place)

Pour que cet examen fonctionne, vous devez ex√©cuter un petit script de pr√©paration ("seed") sur les VM des √©tudiants ou leur fournir une VM pr√©-configur√©e.

**Script de pr√©paration (√† lancer en root avant l'examen) :**

```bash
#!/bin/bash

# 1. Cr√©ation du user 'chef_dev' cass√©
useradd -m -s /bin/false chef_dev
echo "chef_dev:password123" | chpasswd

# 2. Cr√©ation du script bidon pour la partie Processus
cat << 'EOF' > /usr/local/bin/minage_crypto.sh
#!/bin/bash
while true; do
    # Simulation de charge CPU l√©g√®re pour ne pas freezer la VM
    head -n 100 /dev/urandom > /dev/null
    sleep 1
done
EOF
chmod +x /usr/local/bin/minage_crypto.sh

# Lancer le processus en arri√®re-plan pour qu'il soit "d√©j√† l√†"
/usr/local/bin/minage_crypto.sh &

```

### Grille d'√©valuation sugg√©r√©e (Total 25 pts)

**Utilisateurs (9 pts)**

* [2] Diagnostic et correction du shell de `chef_dev` (`grep chef_dev /etc/passwd`).
* [2] Cr√©ation des groupes.
* [3] Utilisateur `alice` (groupes corrects + date d'expiration v√©rifiable avec `chage -l alice`).
* [2] For√ßage changement mdp (`chage -d 0 alice`).

**Permissions (10 pts)**

* [2] Propri√©taire et groupe du dossier corrects.
* [2] Permissions de base (rwx rwx ---).
* [3] Bit SGID fonctionnel (Test : cr√©er un fichier avec alice, v√©rifier le groupe propri√©taire).
* [3] Sticky bit sur `/opt/echanges` (droits 1777 ou rwt).

**Processus (6 pts)**

* [1] Identification du PID correct.
* [2] Changement de priorit√© v√©rifi√© (commande `top` ou `ps -l`).
* [3] Distinction entre SIGTERM (-15) et SIGKILL (-9).

### Pourquoi cet examen teste la compr√©hension ?

1. **Pas de par c≈ìur :** L'√©tudiant ne peut pas simplement taper `useradd bob`. Il doit comprendre les options (`-e`, `-G`) pour r√©pondre aux contraintes temporelles et structurelles.
2. **D√©bogage :** La partie `chef_dev` oblige √† lire les fichiers de configuration pour comprendre *pourquoi* √ßa ne marche pas, plut√¥t que d'appliquer une recette.
3. **SGID/Sticky :** Ce sont des concepts abstraits. Leur demander de les configurer dans un but pr√©cis (h√©ritage de groupe, protection de suppression) valide qu'ils comprennent l'utilit√© du m√©canisme, pas juste la valeur octale.


---

## script de correction automatique
Voici le script de correction automatique (`correction_examen.sh`).

Ce script est con√ßu pour √™tre lanc√© par vous (l'enseignant) directement sur la VM de l'√©tudiant √† la fin de l'√©preuve. Il v√©rifie point par point l'√©tat du syst√®me et calcule la note finale.

### Le Script de Correction (`correction_examen.sh`)

Cr√©ez un fichier nomm√© `correction_examen.sh`, collez le contenu ci-dessous, et rendez-le ex√©cutable (`chmod +x correction_examen.sh`).

```bash
#!/bin/bash

# COULEURS POUR L'AFFICHAGE
VERT='\033[0;32m'
ROUGE='\033[0;31m'
BLEU='\033[0;34m'
NC='\033[0m' # No Color

# VARIABLES DE SCORE
SCORE=0
TOTAL=25

echo -e "${BLEU}======================================================${NC}"
echo -e "${BLEU}       CORRECTION AUTOMATIQUE - EXAMEN LINUX          ${NC}"
echo -e "${BLEU}======================================================${NC}"

# FONCTION DE V√âRIFICATION
check_point() {
    description="$1"
    commande="$2"
    points="$3"

    # Ex√©cution de la commande de test
    if eval "$commande"; then
        echo -e "[ ${VERT}OK${NC} ] $description (+${points} pts)"
        SCORE=$((SCORE + points))
    else
        echo -e "[ ${ROUGE}ECHEC${NC} ] $description (0 pts)"
    fi
}

echo ""
echo -e "${BLEU}--- PARTIE 1 : GESTION UTILISATEURS (9 pts) ---${NC}"

# 1. V√©rif r√©paration chef_dev (shell bash)
check_point "Shell de chef_dev corrig√© (/bin/bash)" \
"grep '^chef_dev:' /etc/passwd | grep -q '/bin/bash'" 2

# 2. V√©rif existence groupes
check_point "Groupe 'frontend' existe" "getent group frontend > /dev/null" 1
check_point "Groupe 'backend' existe" "getent group backend > /dev/null" 1

# 3. V√©rif Alice (Groupes)
# On v√©rifie que le GID principal correspond √† frontend et qu'elle est dans backend
GID_FRONTEND=$(getent group frontend | cut -d: -f3)
check_point "Alice : Groupe principal 'frontend' + secondaire 'backend'" \
"id alice | grep -q 'gid=$GID_FRONTEND(frontend)' && id alice | grep -q 'backend'" 2

# 4. V√©rif Alice (Expiration fin d'ann√©e)
ANNEE_COURANTE=$(date +%Y)
check_point "Alice : Compte expire fin $ANNEE_COURANTE" \
"chage -l alice | grep 'Account expires' | grep -q '$ANNEE_COURANTE'" 1

# 5. V√©rif Alice (Changement MDP forc√©)
# Le champ 'Last password change' doit √™tre √† 0 ou 'password must be changed'
check_point "Alice : Changement MDP forc√© √† la prochaine connexion" \
"chage -l alice | grep 'Last password change' | grep -q 'password must be changed'" 2


echo ""
echo -e "${BLEU}--- PARTIE 2 : PERMISSIONS & ACC√àS (10 pts) ---${NC}"

DIR_SECRET="/opt/projet_secret"
DIR_ECHANGE="/opt/echanges"

# 1. Dossier existe
check_point "Dossier $DIR_SECRET cr√©√©" "[ -d $DIR_SECRET ]" 1

# 2. Propri√©taire et Groupe
check_point "Propri√©taire chef_dev et Groupe backend" \
"[ $(stat -c '%U' $DIR_SECRET) == 'chef_dev' ] && [ $(stat -c '%G' $DIR_SECRET) == 'backend' ]" 2

# 3. Permissions (2770 ou rwxrws---)
# 2770 = SGID (2) + User rwx (7) + Group rwx (7) + Others --- (0)
PERMS=$(stat -c '%a' $DIR_SECRET)
check_point "Permissions SGID et restrictions (2770)" \
"[ '$PERMS' == '2770' ]" 4

# 4. Sticky Bit sur Echanges
# 1777 = Sticky (1) + rwx partout (777)
if [ -d $DIR_ECHANGE ]; then
    PERMS_ECH=$(stat -c '%a' $DIR_ECHANGE)
    check_point "Sticky Bit sur $DIR_ECHANGE (1777)" "[ '$PERMS_ECH' == '1777' ]" 3
else
    echo -e "[ ${ROUGE}ECHEC${NC} ] Dossier $DIR_ECHANGE inexistant (0 pts)"
fi


echo ""
echo -e "${BLEU}--- PARTIE 3 : PROCESSUS (6 pts) ---${NC}"

# 1. V√©rification du fichier r√©ponse PID
FILE_PID="reponse_proc.txt"
# On cherche le fichier n'importe o√π dans le home de l'√©tudiant ou root, ou dossier courant
# Pour simplifier, on suppose qu'il est dans le dossier courant ou /root
if [ -f "$FILE_PID" ]; then
    PID_NOTE=$(head -n 1 $FILE_PID)
    # On v√©rifie si c'est un nombre
    if [[ "$PID_NOTE" =~ ^[0-9]+$ ]]; then
        echo -e "[ ${VERT}OK${NC} ] PID not√© dans $FILE_PID ($PID_NOTE) (+1 pts)"
        SCORE=$((SCORE + 1))
    else
         echo -e "[ ${ROUGE}ECHEC${NC} ] Fichier trouv√© mais contenu invalide"
    fi
else
    echo -e "[ ${ROUGE}ECHEC${NC} ] Fichier $FILE_PID introuvable"
fi

# 2. V√©rification que le processus est bien TU√â
# Comme l'√©tudiant devait le tuer √† la fin, le processus NE DOIT PLUS exister.
if pgrep -f "minage_crypto.sh" > /dev/null; then
    echo -e "[ ${ROUGE}ECHEC${NC} ] Le processus tourne encore (SIGKILL non effectu√©)"
else
    check_point "Processus correctement arr√™t√©" "true" 3
fi

# Note: Pour la priorit√© (Nice), c'est difficile √† v√©rifier post-mortem si le processus est tu√©.
# On accorde les points "de confiance" ou on v√©rifie l'historique bash si disponible.
# Ici, pour l'automatisation, je propose de v√©rifier si l'√©tudiant a laiss√© une trace dans .bash_history
# C'est imparfait, mais mieux que rien pour un script auto.
check_point "Trace de la commande 'renice' ou 'nice' dans l'historique" \
"grep -E 'renice|nice' ~/.bash_history > /dev/null 2>&1 || grep -E 'renice|nice' /home/*/.bash_history > /dev/null 2>&1" 2


echo ""
echo -e "${BLEU}======================================================${NC}"
echo -e "NOTE FINALE : ${SCORE} / ${TOTAL}"
echo -e "${BLEU}======================================================${NC}"

```

### Comment utiliser ce syst√®me en classe

Pour que tout se d√©roule sans accroc le jour de l'examen, voici la proc√©dure id√©ale :

1. **Pr√©paration (Avant le cours) :**
* Pr√©parez le script de mise en place (le "seed" donn√© dans ma r√©ponse pr√©c√©dente) et ce script de correction.
* Mettez-les sur une cl√© USB ou un partage r√©seau accessible (mais cach√©).


2. **Lancement (D√©but de l'examen) :**
* Les √©tudiants d√©marrent leur VM.
* Vous (ou l'√©tudiant) lancez le script de mise en place : `sudo ./setup_exam.sh`. Cela cr√©e le d√©sordre (le user cass√©, le processus qui tourne).


3. **L'Examen :**
* L'√©tudiant travaille. **Rappel important :** Dites aux √©tudiants de lancer la commande `history -a` (append) avant la fin de l'examen pour s'assurer que leurs commandes sont bien sauvegard√©es pour la v√©rification de la partie "renice".


4. **Correction (Fin de l'examen) :**
* Passez sur chaque poste (ou demandez aux √©tudiants de le faire si vous avez confiance).
* Copiez le fichier `correction_examen.sh` sur la machine.
* Ex√©cutez : `sudo ./correction_examen.sh`.
* La note s'affiche instantan√©ment.



### Une astuce p√©dagogique pour le Qu√©bec (C√©gep)

Comme vous enseignez au niveau coll√©gial, vous pouvez ajouter une petite √©tape "auto-√©valuation" :
Donnez ce script aux √©tudiants **en mode "audit"** (sans afficher la note, juste OK/ECHEC) lors d'un laboratoire *formatif* la semaine d'avant. Cela leur apprend √† utiliser des scripts de test unitaire sur leur propre infrastructure ("Test Driven Infrastructure"), une comp√©tence tr√®s pris√©e en DevOps aujourd'hui.

Voulez-vous que je g√©n√®re le fichier PDF de l'√©nonc√© de l'examen pr√™t √† imprimer ?

---

